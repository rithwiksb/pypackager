from __future__ import annotations

import logging
from pathlib import Path
from typing import Optional

from ..core.builder import Builder
from ..core.project import ProjectInfo

logger = logging.getLogger(__name__)


class DockerBuilder(Builder):
    name = "docker"

    def __init__(self, base_image: str = "python:3.12-slim", entrypoint: Optional[str] = None) -> None:
        self._project: ProjectInfo | None = None
        self.base_image = base_image
        self.entrypoint = entrypoint

    def configure(self, project_info: ProjectInfo) -> None:
        self._project = project_info

    def build(self, output_directory: Path) -> None:
        if not self._project:
            raise RuntimeError("DockerBuilder not configured")
        
        output_directory.mkdir(parents=True, exist_ok=True)
        
        # Determine Python version from requires-python or use default
        py_version = self._get_python_version()
        base = self.base_image.replace("<version>", py_version) if "<version>" in self.base_image else self.base_image
        
        # Multi-stage Dockerfile: build stage creates wheels, runtime stage installs them
        dockerfile_content = self._generate_dockerfile(base)
        
        dockerfile = output_directory / "Dockerfile"
        dockerfile.write_text(dockerfile_content, encoding="utf-8")
        
        # Create .dockerignore
        dockerignore = output_directory / ".dockerignore"
        dockerignore.write_text(self._generate_dockerignore(), encoding="utf-8")
        
        logger.info("Docker builder wrote Dockerfile and .dockerignore at %s", output_directory)

    def _get_python_version(self) -> str:
        """Extract Python version from requires-python or default to 3.12."""
        if not self._project or not self._project.python_requires:
            return "3.12"
        
        # Parse requires-python like ">=3.9" to extract base version
        req = self._project.python_requires.strip()
        for prefix in [">=", "~=", "==", ">"]:
            if req.startswith(prefix):
                version_str = req[len(prefix):].strip()
                # Extract major.minor (e.g., "3.9" from "3.9.1")
                parts = version_str.split(".")[:2]
                if len(parts) == 2:
                    return f"{parts[0]}.{parts[1]}"
        
        return "3.12"

    def _generate_dockerfile(self, base: str) -> str:
        """Generate multi-stage Dockerfile content."""
        project_name = self._project.name if self._project else "app"
        
        # Default CMD: run the installed package as a module
        cmd = self.entrypoint if self.entrypoint else f'["python", "-m", "{project_name}"]'
        
        return f'''# Multi-stage Dockerfile generated by pypackager
# Stage 1: Build wheels from source
FROM {base} AS builder

WORKDIR /build
COPY . /build

RUN pip install --no-cache-dir build && \\
    python -m build --wheel --outdir /wheels

# Stage 2: Runtime with installed wheels
FROM {base} AS runtime

WORKDIR /app

# Copy wheels from builder and install
COPY --from=builder /wheels /tmp/wheels
RUN pip install --no-cache-dir /tmp/wheels/*.whl && \\
    rm -rf /tmp/wheels

# Set entrypoint
CMD {cmd}
'''

    def _generate_dockerignore(self) -> str:
        """Generate .dockerignore to exclude build artifacts and venvs."""
        return '''# Python artifacts
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
*.egg-info/
dist/
build/

# Virtual environments
.venv/
venv/
ENV/

# IDE
.vscode/
.idea/
*.swp

# Git
.git/
.gitignore

# Testing
.pytest_cache/
.coverage
htmlcov/

# pypackager artifacts
pypackager.lock
pypackager-venv-*/
dist-test/
'''
